package product_gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"backend/domain/dto"
	gql_utils "backend/utils/gql"
	"context"
	"fmt"
	"strconv"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, payload CreateProductReq) (*CreateProductRespData, error) {
	var err error

	// get current user
	currentUser, ok := ctx.Value("currentUser").(dto.CurrentUser)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// convert payload
	dto := dto.CreateProductReq{
		Name: payload.Name,
	}
	dto.Price, err = strconv.ParseFloat(payload.Price, 64)
	if err != nil {
		return nil, err
	}
	dto.Stock, err = strconv.ParseInt(payload.Stock, 10, 64)
	if err != nil {
		return nil, err
	}

	// process
	data, err := r.productUcase.CreateProduct(ctx, currentUser, dto)

	// convert resp
	// convert resp
	product := &Product{
		UUID:      data.UUID,
		Name:      data.Name,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
	}
	product.Stock = strconv.FormatInt(data.Stock, 10)
	product.Price = strconv.FormatFloat(data.Price, 'f', -1, 64)
	return &CreateProductRespData{Data: product}, err
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, uuid string, payload UpdateProductReq) (*UpdateProductRespData, error) {
	// get current user
	currentUser, err := gql_utils.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// convert payload
	dto := dto.UpdateProductReq{
		Name: payload.Name,
	}
	if payload.Price != nil {
		price, _ := strconv.ParseFloat(*payload.Price, 64)
		dto.Price = &price
	}
	if payload.Stock != nil {
		stock, _ := strconv.ParseInt(*payload.Stock, 10, 64)
		dto.Stock = &stock
	}

	// process
	data, err := r.productUcase.UpdateProduct(ctx, *currentUser, uuid, dto)
	if err != nil {
		return nil, err
	}

	// convert resp
	product := &Product{
		UUID:      data.UUID,
		Name:      data.Name,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
	}
	product.Stock = strconv.FormatInt(data.Stock, 10)
	product.Price = strconv.FormatFloat(data.Price, 'f', -1, 64)
	return &UpdateProductRespData{Data: product}, err
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, uuid string) (*DeleteProductRespData, error) {
	// get current user
	currentUser, err := gql_utils.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// process
	data, err := r.productUcase.DeleteProduct(ctx, *currentUser, uuid)
	if err != nil {
		return nil, err
	}

	// convert resp
	product := &Product{
		UUID:      data.UUID,
		Name:      data.Name,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
	}
	product.Stock = strconv.FormatInt(data.Stock, 10)
	product.Price = strconv.FormatFloat(data.Price, 'f', -1, 64)
	return &DeleteProductRespData{Data: product}, err
}

// GetProductByUUID is the resolver for the getProductByUUID field.
func (r *queryResolver) GetProductByUUID(ctx context.Context, uuid string) (*GetProductByUUIDRespData, error) {
	// proccess
	data, err := r.productUcase.GetByUUID(ctx, uuid)
	if err != nil {
		return nil, err
	}

	// convert resp
	product := &Product{
		UUID:      data.UUID,
		Name:      data.Name,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
	}
	product.Stock = strconv.FormatInt(data.Stock, 10)
	product.Price = strconv.FormatFloat(data.Price, 'f', -1, 64)
	return &GetProductByUUIDRespData{Data: product}, err
}

// GetProductList is the resolver for the getProductList field.
func (r *queryResolver) GetProductList(ctx context.Context, params *GetProductListReq) (*GetProductListRespData, error) {
	// convert params
	dto := dto.GetProductListReq{
		UserUUID:  params.UserUUID,
		Query:     params.Query,
		QueryBy:   params.QueryBy,
		Page:      params.Page,
		Limit:     params.Limit,
		SortOrder: params.SortOrder,
		SortBy:    params.SortBy,
	}

	// process
	data, err := r.productUcase.GetListProduct(ctx, dto)
	if err != nil {
		return nil, err
	}

	// convert resp
	var products []*Product
	for _, v := range data.Data {
		product := &Product{
			UUID:      v.UUID,
			Name:      v.Name,
			CreatedAt: v.CreatedAt.String(),
			UpdatedAt: v.UpdatedAt.String(),
		}
		product.Stock = strconv.FormatInt(v.Stock, 10)
		product.Price = strconv.FormatFloat(v.Price, 'f', -1, 64)
		products = append(products, product)
	}
	resp := GetProductListRespData{
		Total:       strconv.FormatInt(data.Total, 10),
		CurrentPage: strconv.FormatInt(data.CurrentPage, 10),
		TotalPage:   strconv.FormatInt(data.TotalPage, 10),
		Data:        products,
	}
	return &resp, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
