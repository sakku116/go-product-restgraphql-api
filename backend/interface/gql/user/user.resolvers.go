package user_gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"backend/domain/dto"
	"backend/domain/enum"
	gql_utils "backend/utils/gql"
	"context"
	"strconv"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserReq) (*CreateUserRespData, error) {
	// authorize admin
	_, err := gql_utils.GetCurrentUserAdminOnly(ctx)
	if err != nil {
		return nil, err
	}

	// process
	data, err := r.userUcase.CreateUser(ctx, dto.CreateUserReq(input))
	if err != nil {
		return nil, err
	}

	// convert resp
	user := &CreateUserRespData{
		UUID:      data.UUID,
		Username:  data.Username,
		Role:      data.Role,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
		Email:     data.Email,
	}
	return user, err
}

// UpdateUserMe is the resolver for the updateUserMe field.
func (r *mutationResolver) UpdateUserMe(ctx context.Context, input UpdateUserReq) (*UpdateUserRespData, error) {
	// get current user
	currentUser, err := gql_utils.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// convert payload
	dto := dto.UpdateUserReq{
		Username: input.Username,
		Email:    input.Email,
		Password: input.Password,
	}
	if input.Role != nil {
		role := enum.UserRole(*input.Role)
		dto.Role = &role
	}

	// process
	data, err := r.userUcase.UpdateUser(ctx, currentUser.UUID, dto)
	if err != nil {
		return nil, err
	}

	// convert resp
	user := &UpdateUserRespData{
		UUID:      data.UUID,
		Username:  data.Username,
		Role:      data.Role,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
		Email:     data.Email,
	}
	return user, err
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, uuid string, input UpdateUserReq) (*UpdateUserRespData, error) {
	// authorize admin
	_, err := gql_utils.GetCurrentUserAdminOnly(ctx)
	if err != nil {
		return nil, err
	}

	// convert payload
	dto := dto.UpdateUserReq{
		Username: input.Username,
		Email:    input.Email,
		Password: input.Password,
	}
	if input.Role != nil {
		role := enum.UserRole(*input.Role)
		dto.Role = &role
	}

	// process
	data, err := r.userUcase.UpdateUser(ctx, uuid, dto)
	if err != nil {
		return nil, err
	}

	// convert resp
	user := &UpdateUserRespData{
		UUID:      data.UUID,
		Username:  data.Username,
		Role:      data.Role,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
		Email:     data.Email,
	}
	return user, err
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, uuid string) (*DeleteUserRespData, error) {
	// authorize admin
	_, err := gql_utils.GetCurrentUserAdminOnly(ctx)
	if err != nil {
		return nil, err
	}

	data, err := r.userUcase.DeleteUser(ctx, uuid)
	if err != nil {
		return nil, err
	}

	// convert resp
	user := &DeleteUserRespData{
		UUID:      data.UUID,
		Username:  data.Username,
		Role:      data.Role,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
		Email:     data.Email,
	}
	return user, err
}

// GetUserByUUID is the resolver for the getUserByUUID field.
func (r *queryResolver) GetUserByUUID(ctx context.Context, uuid string) (*GetUserByUUIDResp, error) {
	data, err := r.userUcase.GetByUUID(ctx, uuid)
	if err != nil {
		return nil, err
	}

	// convert resp
	user := &GetUserByUUIDResp{
		UUID:      data.UUID,
		Username:  data.Username,
		Role:      data.Role,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
		Email:     data.Email,
	}
	return user, err
}

// GetUserMe is the resolver for the getUserMe field.
func (r *queryResolver) GetUserMe(ctx context.Context) (*GetUserByUUIDResp, error) {
	// get current user
	currentUser, err := gql_utils.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// process
	data, err := r.userUcase.GetByUUID(ctx, currentUser.UUID)
	if err != nil {
		return nil, err
	}

	// convert resp
	user := &GetUserByUUIDResp{
		UUID:      data.UUID,
		Username:  data.Username,
		Role:      data.Role,
		CreatedAt: data.CreatedAt.String(),
		UpdatedAt: data.UpdatedAt.String(),
		Email:     data.Email,
	}
	return user, err
}

// GetUserList is the resolver for the getUserList field.
func (r *queryResolver) GetUserList(ctx context.Context, input *GetUserListReq) (*GetUserListRespData, error) {
	// convert payload
	dto := dto.GetUserListReq{
		Query:   input.Query,
		QueryBy: input.QueryBy,
		SortBy:  input.SortBy,
	}
	if input.Page != nil {
		tmp, err := strconv.Atoi(*input.Page)
		if err != nil {
			return nil, err
		}
		dto.Page = &tmp
	}
	if input.Limit != nil {
		tmp, err := strconv.Atoi(*input.Limit)
		if err != nil {
			return nil, err
		}
		dto.Limit = &tmp
	}
	if input.SortOrder != nil {
		tmp, err := strconv.Atoi(*input.SortOrder)
		if err != nil {
			return nil, err
		}
		dto.SortOrder = &tmp
	}

	// process
	data, err := r.userUcase.GetUserList(ctx, dto)
	if err != nil {
		return nil, err
	}

	// convert resp
	var resp GetUserListRespData
	resp.Total = strconv.FormatInt(data.Total, 10)
	resp.CurrentPage = strconv.FormatInt(data.CurrentPage, 10)
	resp.TotalPage = strconv.FormatInt(data.TotalPage, 10)

	var respData []*GetUserListRespDataUser
	for _, v := range data.Data {
		user := &GetUserListRespDataUser{
			UUID:      v.UUID,
			Username:  v.Username,
			Role:      v.Role.String(),
			CreatedAt: v.CreatedAt.String(),
			UpdatedAt: v.UpdatedAt.String(),
			Email:     v.Email,
		}
		respData = append(respData, user)
	}
	resp.Data = respData
	return &resp, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
